\documentclass[webpdf,contemporary,large,namedate]{oup-authoring-template}%

%\PassOptionsToPackage{hyphens}{url}
%\PassOptionsToPackage{colorlinks,linkcolor=blue,urlcolor=blue,citecolor=blue,anchorcolor=blue}{hyperref}

\DeclareMathOperator*{\argmax}{argmax}

\usepackage{algorithmicx}
\usepackage{lmodern}
\usepackage{setspace}
\renewcommand{\ttdefault}{cmtt}

\begin{document}
\journaltitle{TBD}
\DOI{TBD}
\copyrightyear{2024}
\pubyear{2024}
\access{Advance Access Publication Date: Day Month Year}
\appnotes{Preprint}
\firstpage{1}

\title[BWT construction and query]{BWT construction and search at the terabase scale}
\author[1,2,3,$\ast$]{Heng Li\ORCID{0000-0003-4874-2874}}
\address[1]{Department of Data Science, Dana-Farber Cancer Institute, 450 Brookline Ave, Boston, MA 02215, USA}
\address[2]{Department of Biomedical Informatics, Harvard Medical School, 10 Shattuck St, Boston, MA 02215, USA}
\address[3]{Broad Insitute of Harvard and MIT, 415 Main St, Cambridge, MA 02142, USA}
\corresp[$\ast$]{Corresponding author. \href{mailto:hli@ds.dfci.harvard.edu}{hli@ds.dfci.harvard.edu}}

%\received{Date}{0}{Year}
%\revised{Date}{0}{Year}
%\accepted{Date}{0}{Year}

\abstract{
\sffamily\footnotesize
\textbf{Motivation:}
Burrows-Wheeler Transform (BWT) is a common component in full-text indices.
Initially developed for data compression, it is particularly powerful for encoding redundant sequences such as pangenome data.
However, BWT construction is resource intensive and hard to be parallelized,
and most methods for querying large full-text indices only report exact matches or their simple extensions.
These limitations have hampered the application of full-text indices to large datasets.
\vspace{0.5em}\\
\textbf{Results:}
We developed ropebwt3 for efficient BWT construction and query.
Ropebwt3 could index 100 assembled human genomes in 1.5 days and index 7.3 terabases of commonly studied bacterial assemblies in less than a month.
This was achieved using 82 gigabytes of memory at the peak without working disk space.
Ropebwt3 can also find maximal exact matches and inexact alignment with affine-gap penalties at slower speed.
It demonstrates the feasibility of full-text indexing at terabyte scale.
\vspace{0.5em}\\
\textbf{Availability and implementation:}
\url{https://github.com/lh3/ropebwt3}
}

\maketitle

\section{Introduction}

Although millions of genomes have been sequenced,
the majority of them were sequenced from a small number of species such as human, \emph{E. coli} and \emph{M. tuberculosis}.
As a result, existing genome sequences are highly redundant.
This is how \citet{Hunt2024.03.08.584059} compressed 7.86 terabases (Tb) of bacterial assemblies, also known as AllTheBacteria, into 78.5 gigabytes (GB)
after grouping phylogenetically related genomes~\citep{Brinda:2024aa}.
The resultant compressed files losslessly keep all the sequences but are not directly searchable.
Indexing is necessary to enable fast sequence search.

K-mer data structures are a popular choice for sequence indexing~\citep{Marchet:2021aa}.
They can be classified into three categories.
The first category does not associate k-mers with their positions in the database sequences.
These data structures support membership query, sketching or pseudoalignment,
but cannot be used to reconstruct input sequences or to report base alignment.
Sequence search at the petabase scale use all such methods~\citep{Edgar:2022aa,Karasikov2020.10.01.322164,Shiryev:2024aa}.
The second category associates a subset of k-mers with their positions.
Upon finding k-mer matches, algorithms in this category go back to the database sequences and perform base alignment.
Most aligners work this way.
However, because the database sequences are usually not well compressed,
these algorithms may require large memory or disk space to store them.
The last category keeps all k-mers and their precise positions.
Algorithms in this category can reconstruct all the database sequences without explicitly storing them.
Nonetheless, although positions of k-mers can be compressed efficiently~\citep{Karasikov:2020aa},
they still take large space.
The largest lossless k-mer index is still at terabyte scale~\citep{Karasikov2020.10.01.322164}.

Compressed full-text indices, such as FM-index~\citep{DBLP:conf/focs/FerraginaM00} and r-index~\citep{DBLP:conf/soda/GagieNP18,DBLP:journals/tcs/BannaiGI20,DBLP:journals/jacm/GagieNP20},
provide an alternative way for fast sequence search.
The core component of these data structures is often Burrows-Wheeler Transform (BWT; \citealt*{Burrows:1994aa})
which is a lossless transformation of strings.
The BWT of a highly redundant string tends to group symbols in the original string into long runs
and can thus be well compressed.
When we supplement BWT with a data structure to efficiently compute the rank of a symbol in BWT,
we can in theory count the occurrences of a string $P$ in $O(|P|)$ time where $|P|$ is the length of $P$.
FM-index further adds a sampled suffix array to locate $P$,
while r-index uses an alternative method that is more efficient for highly redundant strings.
Both of them support lossless compression and fast sequence search at the same time.

BWT and FM-index have been used for read alignment~\citep{Langmead:2009aa,Li:2009uq,Li:2009aa},
\emph{de novo} sequence assembly~\citep{Simpson:2012aa} and short-read data compression~\citep{Cox:2012ly}.
Due to the compressibility, BWT-based indicies have also emerged as competent data structures for pangenome data.
Existing pangenome-focused tools~\citep{Rossi:2022aa,Ahmed:2021aa,Zakeri:2024aa}
use prefix-free parsing for BWT construction~\citep{Boucher:2019aa}.
They require more memory than the input sequences which is impractical at the terabyte scale.
Although ropebwt2 developed by us can construct BWT in memory proportional to its compressed size and is fast for short strings~\citep{Li:2014ab},
it is inefficient for chromosome-long sequences.
grlBWT~\citep{DBLP:journals/iandc/DiazDominguezN23} is likely the best algorithm for constructing the BWT of a large collection of similar genomes.
It reduces the peak memory at the cost of large working disk space and frequent disk input/output.
In its current form, the algorithm does not support update to BWT.
We would need to reconstruct the BWT from scratch when new genomes come.
BWT construction for highly redundant sequences remains an active research area.

With BWT-based data structures, it is trivial to test the presence of a string $P$ in the index,
but finding substring matches within $P$ needs more thought.
Learning from bidirectional BWT~\citep{DBLP:conf/bibm/LamLTWWY09},
we found a BWT constructed from both strands of DNA sequences supports the extension of exact matches in both directions~\citep{Li:2012fk}.
This gave us an algorithm to compute maximal exact matches (MEMs), which was later improved by \citet{DBLP:conf/dlt/Gagie24} for long MEMs.
\citet{DBLP:journals/tcs/BannaiGI20} proposed a distinct algorithm to compute MEMs without requiring both strands.
Matching statistics and pseudo-matching length (PML) have also been considered~\citep{Ahmed:2021aa}.
All these algorithms find exact local matches only.

It is also possible to identify inexact local matches.
With the BWT-SW algorithm, \citet{Lam:2008aa} simulated a suffix trie, a tree data structure, with BWT
and performed sequence-to-trie alignment with affine-gap penalty to find all local matches
between a query string and the BWT of a large genome.
We went a step further by representing the query string with its direct acyclic word graph (DAWG; \citealt*{DBLP:journals/eatcs/BlumerBEHM83})
and performed DAWG-to-trie alignment.
This is the BWA-SW algorithm~\citep{Li:2010fk}.
Nonetheless, we later realized the formulation of BWA-SW had theoretical flaws
and its implementation was closer to DAWG-to-DAWG alignment than to DAWG-to-tree alignment.

In this article, we will describe ropebwt3 and explain our solution to BWT construction
and to sequence search at the terabyte scale.
Our contribution includes:
a) a reinterpreted BWA-SW algorithm that fixes issues in our earlier work~\citep{Li:2010fk};
b) the description of core data structures in ropebwt2~\citep{Li:2014ab} and fermi~\citep{Li:2012fk} that were published before but without technical details;
c) an incremental in-memory BWT construction implementation that scales to large pangenome datasets.

\section{Methods}

In a nutshell, ropebwt3 uses the suffix array construction algorithm in libsais to compute the partial multi-string BWT of a subset of sequences
and then merges the partial BWT to the existing BWT run-length encoded as a B+-tree~\citep{Li:2014ab}.
It repeats this procedure until all input sequences are processed.
The BWT by default includes input sequences on both strands.
This enables forward-backward search~\citep{Li:2012fk} required by accelerated long MEM finding~\citep{DBLP:conf/dlt/Gagie24}.
Ropebwt3 also reports local alignment with affine-gap penalty using a revised BWA-SW algorithm~\citep{Li:2010fk}.

Ropebwt3 combines and adapts existing algorithms and data structures.
Nonetheless, the notations here differ from our early work (e.g. from 1-based to 0-based coordinates) and from other publications.
We will describe our methods in full for completeness.

\begin{table}[!tb]
\caption{Notations and naming convention\label{tab:sym}}
\begin{tabular*}{\columnwidth}{@{\extracolsep\fill}ll@{\extracolsep\fill}}
\toprule
Notation & Description \\
\midrule
$\Sigma$   & Alphabet of symbols. $\{{\tt A},{\tt C},{\tt G},{\tt T},{\tt N}\}$ for DNA \\
$\Sigma'$  & Augmented alphabet: $\Sigma'\triangleq\Sigma\cup\{\$\}$ \\
$a,b,c$    & Symbols in $\Sigma'$ \\
$T$        & Concatenated reference string including senteniels \\
$S(i)$     & Suffix array: offset of the $i$-th smallest suffix \\
$B$        & BWT string: $B[i]\triangleq T[S(i)-1]$ \\
$m$        & Number of sentinels: $m\triangleq|\{i:B[i]=\$\}|$ \\
$n$        & Total length: $n\triangleq|T|=|B|$ \\
$r$        & Number of runs: $r\triangleq|\{i:B[i]\not=B[i+1]\}|+1$ \\
$C_B(a)$   & Accumulative count: $C_B(a)\triangleq|\{i:B[i]<a\}|$ \\
${\rm rank}_B(a,k)$ & Rank: ${\rm rank}_B(a,k)\triangleq|\{i<k:B[i]=a\}|$ \\
$\pi(i)$   & LF-mapping: $\pi(i)\triangleq S^{-1}(S(i)-1)$ \\
\botrule
\end{tabular*}
\end{table}

\subsection{Basic concepts}

Let $\Sigma$ be an alphabet of \emph{symbols}.
Given a string $P$ over $\Sigma$, $|P|$ is its length and $P[i]\in\Sigma$, $0\le i<|P|$, is the $i$-th symbol in $P$.
Operator ``$\circ$'' concatenates two strings or between strings and symbols.
It may be omitted if concatenation is apparent from the context.

Suppose $\mathcal{T}=(P_0,P_1,\ldots,P_{m-1})$ is an ordered list of $m$ strings over $\Sigma$.
$T\triangleq P_0\$_0P_1\$_1\cdots P_{m-1}\$_{m-1}$ is the concatenation of the strings in $\mathcal{T}$
with sentiels ordered by $\$_0<\$_1<\cdots<\$_{m-1}$.
There are other ways to define string concatenation on ordered string lists or unordered string sets~\citep{Cenzato:2024ab,Li:2014ab}.
They will be not discussed in this article.

For convenience, let $n\triangleq|T|$ and $T[-1]=T[n-1]$.
The \emph{suffix array} of $T$ is an integer array $S$ such that $S(i)$,
$0\le i<n$, is the start position of the $i$-th smallest suffix among all suffixes of $T$ (Fig.~\ref{fig:1}a).
The \emph{Burrows-Wheeler Transform} (\emph{BWT}) of $T$ is a string $B$ computed by $B[i]=T[S(i)-1]$.
In BWT string $B$, all sentiels are represented by the same symbol ``$\$$'' and are not distinguished from each other.
$\Sigma'\triangleq\Sigma\cup\{\$\}$ denotes the alphabet augmented with the sentinel symbol.

For $a\in\Sigma'$, let $C_B(a)\triangleq|\{i:B[i]<a\}|$ be the number of symbols smaller than $a$
and ${\rm rank}_B(a,k)\triangleq|\{i<k:B[i]=a\}|$ be the number of $a$ before position $k$ in $B$.
We may omit subscription $B$ when we are describing one string only.
The last-to-first mapping (\emph{LF mapping}) $\pi$ is defined by $\pi(i)\triangleq S^{-1}(S(i)-1)$,
where $S^{-1}$ is the inservse function of suffix array $S$.
It can be calculated as $\pi(i)=C(B[i])+{\rm rank}(B[i],i)$.
As $B[\pi(i)]$ immediately preceeds $B[i]$ on $T$, we can use $\pi$ to decode the $i$-th sequence in $B$ (Algorithm~\ref{algo:get}).

\begin{figure}[bt]
\centering
\includegraphics[width=.49\textwidth]{fig1}
\caption{Examples of BWT and related data structures.
{\bf (a)} The BWT $B$, suffix arrary $S$ and LF-mapping $\pi$ of string $T$.
Subscriptions are equal to the ranks of symbols in $B$, which are the same as the ranks among the suffixes (indicated by arrows).
{\bf (b)} The prefix trie simulated with BWT $B$.
In each node, the pair of integers gives the suffix array interval of the string represented by the path from the node to the root.
{\bf (c)} The directed acyclic prefix graph (DAPG) of $T$ by merging nodes with identical suffix array intervals.}\label{fig:1}
\end{figure}

\begin{algorithm}[!b]
	\caption{Retrieve the $i$-th sequence, $0\le i<m$}\label{algo:get}
	\begin{algorithmic}[1]
		\Procedure{Retrieve}{$B,i$}
			\State $P\gets\epsilon$\Comment{empty string}
			\While{$B[i]\not=\$$}
			\State $P\gets B[i]\circ P$
			\State $i\gets C_B(B[i])+{\rm rank}(B[i],i)$\Comment{i.e. $i\gets\pi(i)$}
			\EndWhile
			\State \Return{$P$}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\subsection{Suffix array internval and backward search}

For a string $P\in\Sigma^*$ (i.e. not including sentinels), let $L(P)$ be the number of $T$'s suffixes prefixed with $P$.
Define ${\rm lo}(P)$ to be the number of suffixes that lexicographically smaller than $P$
and ${\rm hi}(P)\triangleq {\rm lo}(P)+L(P)$.
$[{\rm lo}(P),{\rm hi}(P))$ is called the \emph{suffix array interval} of $P$, or \emph{SA interval} in brief.

If we know the SA interval of $P$, we can calculate the SA interval of $aP$ with:
\begin{eqnarray*}
{\rm lo}(aP)&=&C(a)+{\rm rank}(a,{\rm lo}(P))\\
{\rm hi}(aP)&=&C(a)+{\rm rank}(a,{\rm hi}(P))
\end{eqnarray*}
To count the occurrence of a string $P$,
we can start with the SA interval $[0,n)$ of an empty string and repeatedly apply the equation above from the last symbol in $P$ to the first.
This procedure is called \emph{backward search}.

\subsection{Double-strand BWT}

The definitions above are applicable to generic strings.
With one BWT, we can only achieve backward search;
forward search requires the BWT of reverse strings~\citep{DBLP:conf/bibm/LamLTWWY09}.
Nonetheless, due to the strand symmetry of DNA strings,
it is possible to achieve both forward and backward search with one BWT provided that the BWT contains both strands of DNA strings.

Formally, a DNA alphabet is $\Sigma=\{{\tt A},{\tt C},{\tt G},{\tt T},{\tt N}\}$.
$\overline{a}$ denotes the Watson-Crick complement of symbol $a\in\Sigma$.
The complement of $\$$, ${\tt A}$, ${\tt C}$, ${\tt G}$, ${\tt T}$ and ${\tt N}$
are $\$$, ${\tt T}$, ${\tt G}$, ${\tt C}$, ${\tt A}$ and ${\tt N}$, respectively.

For string $P$, $\overline{P}$ is its reverse complement string.
The double-strand concatenation of a DNA string list $\mathcal{T}=(P_0,P_1,\ldots,P_{m-1})$ is
$\tilde{T}=P_0\$_0\overline{P}_0\$_1P_1\$_2\overline{P}_1\$_3\cdots P_{m-1}\$_{2m-2}\overline{P}_{m-1}\$_{2m-1}$.
The \emph{double-strand BWT} (\emph{DS-BWT}) of $\mathcal{T}$ is the BWT of $\tilde{T}$.

We note that if $P$ is a substring of $\tilde{T}$,
$\overline{P}$ must be a substring as well and the occurrences of $P$ and $\overline{P}$ are identical.
We can thus define the \emph{suffix array bidirectional interval} (\emph{SA bi-interval}) of $P$
as a 3-tuple $(k,k',s)$ where $[k,k+s)$ is the SA interval of $P$ and $[k',k'+s)$ is the SA interval of $\overline{P}$.
It is easy to see that if $(k,k',s)$ is the SA bi-interval of $P$, $(k',k,s)$ will be the SA bi-interval of $\overline{P}$, and vice versa.

\begin{algorithm}[!htb]
	\caption{Backward and forward extensions with DS-BWT}
	\begin{algorithmic}[1]
		\Procedure{BackwardExt}{$B,(k,k',s),a$}
			\State $t\gets 0$
			\ForAll{$b<\overline{a}$}\Comment{$b$ can be $\$$}
				\State $t\gets t+\big[{\rm rank}(\overline{b},k+s)-{\rm rank}(\overline{b},k)\big]$
			\EndFor
			\State $s\gets {\rm rank}(a,k+s)-{\rm rank}(a,k)$
			\State $k\gets C(a)+{\rm rank}(a,k)$
			\State \Return{$(k,k'+t,s)$}
		\EndProcedure
		\Procedure{ForwardExt}{$B,(k,k',s),a$}
			\State $(k',k,s)\gets${\sc BackwardExt}$(B,(k',k,s),\overline{a})$
			\State \Return{$(k,k',s)$}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htb]
	\caption{Append BWT $B_2$ into BWT $B_1$}\label{algo:merge}
	\begin{algorithmic}[1]
		\Procedure{AppendBWT}{$B_1,B_2$}
			\State $m_1\gets\mbox{number of sentinels in $B_1$ }$
			\State $m_2\gets\mbox{number of sentinels in $B_2$ }$
			\State $A\gets \emptyset$
			\For{$i\gets 0$ {\bf to} $m_2$}
				\State $k\gets i$
				\State $l\gets m_1$
				\Repeat
					\State $a\gets B_2[k]$
					\State $A\gets A\cup \{(k+l,a)\}$
					\State $k\gets C_{B_2}(a)+{\rm rank}_{B_2}(a,k)$
					\State $l\gets C_{B_1}(a)+{\rm rank}_{B_1}(a,l)$
				\Until{$a=\$$}
			\EndFor
			\For{$(k,a)\in A$ in ascending order of $k$}
				\State ${\rm insert}_{B_1}(a,k)$
			\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{The revised BWA-SW algorithm}\label{algo:bwa-sw}
	\begin{algorithmic}[1]
		\Procedure{BwaSW}{$G_P,G_T$}
			\For{$u\in V(G_P)$ in topological order}
				\For{$u'\in{\rm pre}(u)$}\Comment{predecessors of $u$}
					\For{$v\in V(G_T)$ \emph{s.t.} $H_{u'v}>0$}\Comment{insertion}
						\State $E_{uv}\gets\max\{E_{uv},\max\{H_{u'v}-q,E_{u'v}\}-e\}$
						\State $H_{uv}\gets\max\{H_{uv},E_{uv}\}$
					\EndFor
					\For{$v'\in V(G_T)$ \emph{s.t.} $H_{u'v'}>0$}\Comment{match}
						\For{$v\in{\rm child}(v')$}\Comment{children of $v'$}
							\State $H_{uv}\gets \max\{H_{uv},H_{u'v'}+s(u',u;v',v)\}$
						\EndFor
					\EndFor
				\EndFor
				\For{$v'\in V(G_T)$ \emph{s.t.} $H_{uv'}>0$}\Comment{deletion}
					\For{$v\in{\rm child}(v')$}\Comment{children of $v'$}
						\State $F_{uv}\gets\max\{F_{uv},\max\{H_{uv'}-q,F_{uv'}\}-e\}$
						\State $H_{uv}\gets\max\{H_{uv},F_{uv}\}$
					\EndFor
				\EndFor
			\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\section{Results}

\begin{table}[!tb]
\caption{Datasets\label{tab:data}}
\begin{tabular*}{\columnwidth}{@{\extracolsep\fill}lrrr@{\extracolsep\fill}}
\toprule
Name               & \#bases$^1$ & \#sequences & avg run length$^2$ \\
\midrule
human100$^3$       &  301.6 Gb &  38.6 k & 141.6 \\
CommonBacteria$^4$ & 7326.6 Gb & 278.4 M & 828.6 \\
\botrule
\end{tabular*}
\begin{tablenotes}\setlength\itemsep{0.0em}
\item[$^{1}$] number of bases in the input sequences on one strand
\item[$^{2}$] average run length in BWT constructed from both strands
\item[$^{3}$] 100 long-read human assemblies
\item[$^{4}$] AllTheBacteria~\citep{Hunt2024.03.08.584059} excluding ``dustbin'' and ``unknown''
\end{tablenotes}
\end{table}

\begin{table}[!tb]
\caption{Indexing performance\label{tab:index}}
\begin{tabular*}{\columnwidth}{@{\extracolsep\fill}llrrr@{\extracolsep\fill}}
\toprule
Dataset        & Algorithm     & Elapsed$^1$ & CPU$^1$  &     RAM \\
\midrule
human100       & grlBWT        &  8.3 h       &  29.6 h &  84.8 GB \\
		       & pfp-thres$^2$ & 51.7 h       &  51.5 h & 788.1 GB \\
               & ropebwt3$^3$  & 33.7 h       & 803.6 h &  82.3 GB \\
			   & metagraph$^4$ & 16.9 h       & 314.8 h & 251.0 GB \\
			   & fulgor$^5$ (lossy)& 1.2 h    &  32.7 h & 165.2 GB \\
CommonBacteria & ropebwt3$^3$  & 26.5 d       & 830.3 d &  67.3 GB \\
\botrule
\end{tabular*}
\begin{tablenotes}\setlength\itemsep{0.0em}
\item Up to 64 threads specified if multi-threading is supported.
\item[$^{1}$] excluding time for format conversion; ``h'' for hours; ``d'' for days
\item[$^{2}$] pfp-threshold was run on a slower machine with more RAM
\item[$^{3}$] not using temporary disk space; supporting incremental build
\item[$^{4}$] k-mer coordinates in the ``row\_diff\_brwt\_coord'' encoding
\item[$^{5}$] without ``-{}-meta -{}-diff'' as the basic index is smaller; lossy index
\end{tablenotes}
\end{table}

\begin{table}[!tb]
\caption{Query performance\label{tab:query}}
\begin{tabular*}{\columnwidth}{@{\extracolsep\fill}lllrr@{\extracolsep\fill}}
\toprule
Data   & Algorithm     &Type$^4$&Speed$^5$ (kb/s)&RAM (GB) \\
\midrule
SR$+^1$& ropebwt3      & MEM31  & 1758.5       &  10.6 \\
       &               & MEM51  & 1907.5       &  10.6 \\
       &               & suffix & 2216.4       &  10.3 \\
	   & MONI$^6$      & MEM$-$ & 453.2        &  68.4 \\
       & Movi          & PML    & 5894.0       &  79.4 \\
	   &               & suffix & 6792.0       &  79.4 \\
	   & metagraph     & PA$+$  & $<$0.1       &  65.3 \\
	   & fulgor        & PA     & 2717.5       &   5.1 \\
LR$+^2$& ropebwt3      & MEM31  & 1695.9       &  10.5 \\
       &               & MEM51  & 1793.9       &  10.5 \\
       &               & SW     & 82.7         &  15.6 \\
	   & MONI          & MEM$-$ & 413.6        &  68.4 \\
	   & Movi          & PML    & 16204.9      &  79.4 \\
	   & metagraph     & PA$+$  & $<$0.1       &  65.3 \\
	   & fulgor        & PA     & 2491.6       &   5.1 \\
LR$-^3$& ropebwt3      & MEM31  & 1365.0       &  10.4 \\
       &               & MEM51  & 3051.6       &  10.4 \\
	   &               & SW     & 58.2         &  17.9 \\
	   & MONI          & MEM$-$ & 186.8        &  68.4 \\
	   & Movi          & PML    & 8490.9       &  79.4 \\
	   & metagraph     & PA$+$  & 1119.3       &  65.3 \\
	   & fulgor        & PA     & 4240.8       &   5.1 \\
\botrule
\end{tabular*}
\begin{tablenotes}\setlength\itemsep{0.0em}
\item[$^1$] first 1 million 125bp human short reads from SRR3099549
\item[$^2$] first 10,000 human PacBio HiFi reads from SRR26545347
\item[$^3$] first 10,000 metagenomic PacBio HiFi reads from DRR290133
\item[$^4$] MEM31: maximal exact matches (MEMs) of 31bp or longer; MEM51: MEM of $\ge$51bp;
suffix: longest matching suffix with counts; MEM$-$: MEM without count;
SW: BWA-SW; PML: pseudo-matching length; PA: pseudo-alignment; PA$+$: pseudo-alignment with contig names
\item[$^5$] kilobases processed per CPU second. Index loading time excluded
\item[$^6$] The MONI index includes both strands
\end{tablenotes}
\end{table}

\section{Discussions}

\section*{Acknowledgements}

\section*{Author contributions}

H.L. conceived the project, implemented the algorithms, analyzed the data and drafted the manuscript.

\section*{Conflict of interest}

None declared.

\section*{Funding}

This work is supported by National Institute of Health grant R01HG010040 and U01HG010961 (to H.L.).

\section*{Data availability}

Source code available at \url{https://github.com/lh3/ropebwt3}

\bibliographystyle{apalike}
{\sffamily\small
\bibliography{ropebwt3}}

\end{document}
